(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{638:function(a,t,s){"use strict";s.r(t);var r=s(7),n=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("p",[a._v("写过前端的都知道，REST 风格的 API 适合简单的增删改查。对于稍微复杂的关联查询，就显得不太合适：如果设计一个 REST 接口，一般情况下会返回关联表的全部字段，以满足更多类似的查询需求，如果设计多个细粒度接口，前端就需要查询很多次，自己拼装数据。粗粒度的接口导致不必要的数据传输，细粒度的接口导致函数爆炸，你见过 JavaScript 的 Promise 满天飞吧。")]),a._v(" "),s("p",[a._v("在此情景下 Facebook 的工程师于 2015 年开源了 GraphQL 规范，让前端自己描述自己希望的数据形式，服务端则返回前端所描述的数据结构。简单的来说，前端要啥，后端就返回啥，非常灵活。")]),a._v(" "),s("h3",{attrs:{id:"什么是-graphql"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是-graphql"}},[a._v("#")]),a._v(" 什么是 GraphQL？")]),a._v(" "),s("p",[a._v("简单来说，GraphQL 是一种面向数据的 API 查询风格，把所有数据都被视为已连接的图形，客户端能够准确地获得它需要的数据，没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。")]),a._v(" "),s("p",[a._v("比如，前端只需要 hero 的 name，那么后端就只返回这个 name，没有冗余：\n"),s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNgy1gptge8e0xsg30cj09ht8q.gif",alt:""}})]),a._v(" "),s("p",[a._v("再比如：前端需要显示作者的帖子信息，作者本人的信息，作者的关注者列表，假如是 REST，前端需要请求这三个接口，再组装：")]),a._v(" "),s("ul",[s("li",[a._v("/user/<id> 获取用户（作者）详细信息，可能是名称。")]),a._v(" "),s("li",[a._v("/user/<id>/posts 获取该用户发布的帖子列表。")]),a._v(" "),s("li",[a._v("/user/<id>/followers 获取用户的关注者列表。")])]),a._v(" "),s("p",[a._v("现在我们可以通过 GraphQL 的一次查询拿到全部信息，无需从好几个异步 API 里面来回找：")]),a._v(" "),s("div",{staticClass:"language-yaml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-yaml"}},[s("code",[a._v("query "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("User(id")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" '123') "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    name\n    posts "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n      title\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    followers "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n      name\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br")])]),s("p",[a._v("简洁明了，不是吗？")]),a._v(" "),s("h3",{attrs:{id:"graphql-带来的改变"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#graphql-带来的改变"}},[a._v("#")]),a._v(" GraphQL 带来的改变")]),a._v(" "),s("p",[a._v("目前主流就就是前后端分离，前后端只通过 API 来交流，结构大概如下图：")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNgy1gptgfbgg53j30j50gu0sz.jpg",alt:""}})]),a._v(" "),s("p",[a._v("如果使用 GraphQL，那么后端将不再产出 API，而是将 Controller 层维护为 Resolver，和前端约定一套 Schema，这个 Schema 将用来生成接口文档，前端直接通过 Schema 或生成的接口文档来进行自己期望的请求。")]),a._v(" "),s("p",[a._v("经过几年一线开发者的填坑，已经有一些不错的"),s("a",{attrs:{href:"https://github.com/chentsulin/awesome-graphql",target:"_blank",rel:"noopener noreferrer"}},[a._v("awesome-graphql"),s("OutboundLink")],1),a._v("用于开发与生产，很多语言也提供了对 GraphQL 的支持，比如 JavaScript/Nodejs、Java、PHP、Ruby、Python、Go、C# 等。")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNgy1gptb4949tpj314l0u0gpp.jpg",alt:""}})]),a._v(" "),s("h3",{attrs:{id:"graphql-的使用趋势"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#graphql-的使用趋势"}},[a._v("#")]),a._v(" GraphQL 的使用趋势")]),a._v(" "),s("p",[a._v("一些比较有名的公司正在转换 REST API 到 GraphQL，比如 Twitter、IBM、Coursera、Airbnb、Facebook、Github、携程等 特别是 Github，它的 v4 版外部 API 只使用 GraphQL。据一位在 Twitter 工作的大佬说硅谷不少一线二线的公司都在想办法转到 GraphQL 上，但是同时也说了 GraphQL 还需要时间发展，因为将它使用到生产环境需要前后端大量的重构，这无疑需要高层的推动和决心。")]),a._v(" "),s("h3",{attrs:{id:"graphql-的局限性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#graphql-的局限性"}},[a._v("#")]),a._v(" GraphQL 的局限性")]),a._v(" "),s("p",[a._v("对于简单的应用程序而言，设置类型，查询等 可能会有些复杂 ，因为可以使用 REST 轻松完成。")]),a._v(" "),s("p",[a._v("对于复杂的查询，GraphQL 只需要一次，虽然网络层面的请求数被优化了，数据库层面的查询可一点都不少，数据库查询可能会成为性能瓶颈，有很大的优化空间。")]),a._v(" "),s("h3",{attrs:{id:"graphql-的优势"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#graphql-的优势"}},[a._v("#")]),a._v(" GraphQL 的优势")]),a._v(" "),s("p",[a._v("检索精确的数据，没有冗余。通常，当数据需求发生变化时，您只需要修改查询，并且不需要太多更改，从而提高前后端的开发效率，从而可以快速进行产品迭代。")]),a._v(" "),s("h3",{attrs:{id:"最后的话"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最后的话"}},[a._v("#")]),a._v(" 最后的话")]),a._v(" "),s("p",[a._v("GraphQL 已经被各种体量的团队所使用，在不同的环境、不同的语言下，用于增强移动应用、网站和 API。如果你已经厌倦了 REST API，现在是时候学习一下 GraphQL 了。\n关注公众号「Python七号」，学习更多技术干货。")])])}),[],!1,null,null,null);t.default=n.exports}}]);
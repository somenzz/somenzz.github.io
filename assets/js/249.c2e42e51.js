(window.webpackJsonp=window.webpackJsonp||[]).push([[249],{817:function(t,i,s){"use strict";s.r(i);var _=s(7),a=Object(_.a)({},(function(){var t=this,i=t.$createElement,s=t._self._c||i;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("你好，我是 somenzz，Python 的灵活程度让人发指，今天来分享一下关于字典的疯狂操作，计算斐波那契数列，话不多说，先看代码:")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/e6c9d24egy1h2saqfzzdgj21540msdhh.jpg",alt:""}})]),t._v(" "),s("p",[t._v("代码定义了一个类 FibDict，继承自 dict，自定义了魔术方法 "),s("code",[t._v("__missing__")]),t._v("  当 dict 查找 key 失败(missing)的时候，会由 Python 解释器自行调用改方法。换句话说，如果试图从 dict 中获取不存在的 key，就会执行这个方法。")]),t._v(" "),s("p",[t._v("因此计算 fib_dict[10] 就会执行这个方法，计算 fib_dict[9] 和 fib_dict[8]，就这样递归，一直到 fib_dict[0] 和 fib_dict[1]。")]),t._v(" "),s("p",[t._v("这是递归，但是字典是一种 hash 表，只要计算过的数据不会重复计算，因此效率非常高。")]),t._v(" "),s("p",[t._v("我们可以验证下计算 fib_dict[200] 的耗时：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/e6c9d24egy1h2sb86kdtrj20vj0u0dim.jpg",alt:""}})]),t._v(" "),s("p",[t._v("可以看出连 1 毫秒都不到。")]),t._v(" "),s("p",[t._v("不过，递归虽爽，可不要贪杯哦，任何事情都有极限，500 是递归的默认极限，如果你直接计算 fib_dict[501] 就抛出 RecursionError 异常。")]),t._v(" "),s("p",[t._v("但是，字典是有记忆的，如果你这样调用它，永远不会出现递归的问题：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/e6c9d24egy1h2sbsutcz3j20o80hg0tk.jpg",alt:""}})]),t._v(" "),s("h2",{attrs:{id:"最后的话"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最后的话"}},[t._v("#")]),t._v(" 最后的话")]),t._v(" "),s("p",[t._v("如果一段代码让你眼前一亮，那还有什么理由不分享呢？ 如果有帮助，点赞、在看、转发。点击下方的卡片或扫一扫关注我，给你提供 Python 技术支持。")])])}),[],!1,null,null,null);i.default=a.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{680:function(_,v,e){"use strict";e.r(v);var t=e(7),n=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("p",[_._v("在 GitHub 看到一篇很不错的学习资料，其中提到 Python 是如何管理内存的，我看完后很有收获，如下：")]),_._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/jackfrued/Python-Interview-Bible/blob/master/Python%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-%E5%9F%BA%E7%A1%80%E7%AF%87-2020.md",target:"_blank",rel:"noopener noreferrer"}},[_._v("原文"),e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("当面试官问到这个问题的时候，一个展示自己的机会就摆在面前了。你要先反问面试官：“你说的是官方的CPython解释器吗？”。这个反问可以展示出你了解过 Python 解释器的不同的实现版本，而且你也知道面试官想问的是 CPython。当然，很多面试官对不同的 Python 解释器底层实现到底有什么差别也没有概念。所以，千万不要觉得面试官一定比你强，怀揣着这份自信可以让你更好的完成面试。")]),_._v(" "),e("p",[_._v("Python 提供了自动化的内存管理，也就是说内存空间的分配与释放都是由 Python 解释器在运行时自动进行的，自动管理内存功能极大的减轻程序员的工作负担，也能够帮助程序员在一定程度上解决内存泄露的问题。")]),_._v(" "),e("p",[_._v("以 CPython 解释器为例，它的内存管理有三个关键点：引用计数、标记清理、分代收集。")]),_._v(" "),e("div",{staticClass:"language-c line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("typedef")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("struct")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[_._v("_object")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("{")]),_._v("\n    _PyObject_HEAD_EXTRA\n    Py_ssize_t ob_refcnt"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("struct")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[_._v("_typeobject")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("*")]),_._v("ob_type"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("}")]),_._v(" PyObject"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n")])]),_._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[_._v("1")]),e("br"),e("span",{staticClass:"line-number"},[_._v("2")]),e("br"),e("span",{staticClass:"line-number"},[_._v("3")]),e("br"),e("span",{staticClass:"line-number"},[_._v("4")]),e("br"),e("span",{staticClass:"line-number"},[_._v("5")]),e("br")])]),e("p",[_._v("引用计数：对于 CPython 解释器来说，Python 中的每一个对象其实就是 PyObject 结构体，它的内部有一个名为 ob_refcnt 的引用计数器成员变量。程序在运行的过程中 ob_refcnt 的值会被更新，并用 ob_refcnt 来反映有多少个变量引用到该对象。当对象的引用计数值为 0 时，它的内存就会被释放掉。")]),_._v(" "),e("p",[_._v("以下情况会导致引用计数加 "),e("code",[_._v("1")]),_._v("：")]),_._v(" "),e("ul",[e("li",[_._v("对象被创建")]),_._v(" "),e("li",[_._v("对象被引用")]),_._v(" "),e("li",[_._v("对象作为参数传入到一个函数中")]),_._v(" "),e("li",[_._v("对象作为元素存储到一个容器中")])]),_._v(" "),e("p",[_._v("以下情况会导致引用计数减 "),e("code",[_._v("1")]),_._v("：")]),_._v(" "),e("ul",[e("li",[_._v("用"),e("code",[_._v("del")]),_._v("语句显示删除对象引用")]),_._v(" "),e("li",[_._v("对象引用被重新赋值其他对象")]),_._v(" "),e("li",[_._v("一个对象离开它所在的作用域")]),_._v(" "),e("li",[_._v("持有该对象的容器自身被销毁")]),_._v(" "),e("li",[_._v("持有该对象的容器删除该对象")])]),_._v(" "),e("p",[_._v("可以通过 "),e("code",[_._v("sys")]),_._v(" 模块的 "),e("code",[_._v("getrefcount")]),_._v(" 函数来获得对象的引用计数。引用计数的内存管理方式在遇到循环引用的时候就会出现致命伤，因此需要其他的垃圾回收算法对其进行补充。")]),_._v(" "),e("p",[e("strong",[_._v("标记清理")])]),_._v(" "),e("p",[_._v("CPython使用了“标记-清理”（Mark and Sweep）算法解决容器类型可能产生的循环引用问题。该算法在垃圾回收时分为两个阶段：标记阶段，遍历所有的对象，如果对象是可达的（被其他对象引用），那么就标记该对象为可达；清除阶段，再次遍历对象，如果发现某个对象没有标记为可达，则就将其回收。")]),_._v(" "),e("p",[_._v("CPython 底层维护了两个双端链表，一个链表存放着需要被扫描的容器对象，姑且称之为链表 A，另一个链表存放着临时不可达对象，姑且称之为链表 B。为了实现“标记-清理”算法，链表中的每个节点除了有记录当前引用计数的 "),e("code",[_._v("ref_count")]),_._v(" 变量外，还有一个 "),e("code",[_._v("gc_ref")]),_._v(" 变量，这个 "),e("code",[_._v("gc_ref")]),_._v(" 是 "),e("code",[_._v("ref_count")]),_._v(" 的一个副本，所以初始值为 "),e("code",[_._v("ref_count")]),_._v(" 的大小。执行垃圾回收时，首先遍历链表 A 中的节点，并且将当前对象所引用的所有对象的 "),e("code",[_._v("gc_ref")]),_._v(" 减 "),e("code",[_._v("1")]),_._v("，这一步主要作用是解除循环引用对引用计数的影响。再次遍历链表 A 中的节点，如果节点的"),e("code",[_._v("gc_ref")]),_._v("值为"),e("code",[_._v("0")]),_._v("，那么这个对象就被标记为“暂时不可达”（"),e("code",[_._v("GC_TENTATIVELY_UNREACHABLE")]),_._v("）并被移动到链表B中；如果节点的"),e("code",[_._v("gc_ref")]),_._v("不为"),e("code",[_._v("0")]),_._v("，那么这个对象就会被标记为“可达”（"),e("code",[_._v("GC_REACHABLE")]),_._v("），对于“可达”对象，还要递归的将该节点可以到达的节点标记为“可达”；链表B中被标记为“可达”的节点要重新放回到链表A中。在两次遍历之后，链表 B 中的节点就是需要释放内存的节点。")]),_._v(" "),e("p",[e("strong",[_._v("分代回收")])]),_._v(" "),e("p",[_._v("在循环引用对象的回收中，整个应用程序会被暂停，为了减少应用程序暂停的时间，Python 通过分代回收（空间换时间）的方法提高垃圾回收效率。分代回收的基本思想是："),e("strong",[_._v("对象存在的时间越长，是垃圾的可能性就越小，应该尽量不对这样的对象进行垃圾回收")]),_._v("。CPython将对象分为三种世代分别记为 "),e("code",[_._v("0")]),_._v("、"),e("code",[_._v("1")]),_._v("、"),e("code",[_._v("2")]),_._v("，每一个新生对象都在第 "),e("code",[_._v("0")]),_._v(" 代中，如果该对象在一轮垃圾回收扫描中存活下来，那么它将被移到第 "),e("code",[_._v("1")]),_._v(" 代中，存在于第 "),e("code",[_._v("1")]),_._v(" 代的对象将较少的被垃圾回收扫描到；如果在对第 "),e("code",[_._v("1")]),_._v(" 代进行垃圾回收扫描时，这个对象又存活下来，那么它将被移至第 "),e("code",[_._v("2")]),_._v(" 代中，在那里它被垃圾回收扫描的次数将会更少。分代回收扫描的门限值可以通过 "),e("code",[_._v("gc")]),_._v(" 模块的 "),e("code",[_._v("get_threshold")]),_._v(" 函数来获得，该函数返回一个三元组，分别表示多少次内存分配操作后会执行 "),e("code",[_._v("0")]),_._v(" 代垃圾回收，多少次 "),e("code",[_._v("0")]),_._v(" 代垃圾回收后会执行 "),e("code",[_._v("1")]),_._v(" 代垃圾回收，多少次 "),e("code",[_._v("1")]),_._v(" 代垃圾回收后会执行 "),e("code",[_._v("2")]),_._v(" 代垃圾回收。需要说明的是，如果执行一次 "),e("code",[_._v("2")]),_._v(" 代垃圾回收，那么比它年轻的代都要执行垃圾回收。如果想修改这几个门限值，可以通过 "),e("code",[_._v("gc")]),_._v(" 模块的 "),e("code",[_._v("set_threshold")]),_._v(" 函数来做到。")]),_._v(" "),e("h3",{attrs:{id:"最后的话"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#最后的话"}},[_._v("#")]),_._v(" 最后的话")]),_._v(" "),e("p",[_._v("学习一门编程语言，一定要弄明白它是如何管理内存的，这不仅是如何应付面试的问题，更是如何更好的使用编程语言的基础。内存管理的一些算法设计，也有助于我们应对一些复杂的系统设计，学好它很有必要。")]),_._v(" "),e("p",[_._v("学习无止境，学的越多，就越觉得不知道的越多，但是学的越多，就越知道自己的边界，也就越不怕未知，这也是学习的意义。")])])}),[],!1,null,null,null);v.default=n.exports}}]);